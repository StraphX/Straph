

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>straph.dag.condensation_dag &mdash; straph 1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> straph
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">straph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>straph.dag.condensation_dag</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for straph.dag.condensation_dag</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">msgpack</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pathlib</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcol</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatch</span>

<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">joblib</span> <span class="k">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="k">import</span> <span class="n">ascii_uppercase</span>
<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">paths</span> <span class="k">as</span> <span class="n">pt</span>
<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">stream</span> <span class="k">as</span> <span class="n">sg</span>
<span class="kn">from</span> <span class="nn">straph</span> <span class="k">import</span> <span class="n">components</span> <span class="k">as</span> <span class="n">scc</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">from</span> <span class="nn">straph.utils</span> <span class="k">import</span> <span class="n">profile_shit</span>


<div class="viewcode-block" id="load_scc_dag"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.load_scc_dag">[docs]</a><span class="k">def</span> <span class="nf">load_scc_dag</span><span class="p">(</span><span class="n">path_nodes</span><span class="p">,</span> <span class="n">path_links</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">scc_dag</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_nodes</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="n">S</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path_links</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_links</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
            <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
                <span class="n">S</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="load_scc_dag_scf"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.load_scc_dag_scf">[docs]</a><span class="k">def</span> <span class="nf">load_scc_dag_scf</span><span class="p">(</span><span class="n">path_scc_dag</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Load a SCC DAG</span>
<span class="sd">    :param path_scc_dag:</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dict_dag</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_dag</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
            <span class="c1"># if len(i[1]) &gt; 1:  # We are only interested with DAG with at least 2 nodes</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">scc_dag</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">S</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">S</span><span class="o">.</span><span class="n">set_id</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dict_dag</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">dict_dag</span></div>


<div class="viewcode-block" id="compute_dict_offset"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.compute_dict_offset">[docs]</a><span class="k">def</span> <span class="nf">compute_dict_offset</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">scc_2_offset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># SCC components are ordered by their end time</span>
            <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">scc_2_offset</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)]</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">storage_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">msgpack</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">scc_2_offset</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scc_2_offset</span></div>


<div class="viewcode-block" id="load_dag_from_ids"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.load_dag_from_ids">[docs]</a><span class="k">def</span> <span class="nf">load_dag_from_ids</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_offset</span><span class="p">:</span>
        <span class="n">dict_offset</span> <span class="o">=</span> <span class="n">compute_dict_offset</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">file_input</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">dict_offset</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scc_dag</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c_nodes</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c_links</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="read_global_dag"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.read_global_dag">[docs]</a><span class="k">def</span> <span class="nf">read_global_dag</span><span class="p">(</span><span class="n">dag_path</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">scc_dag</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dag_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ipt</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">ipt</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="merge_scc_dags"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.merge_scc_dags">[docs]</a><span class="k">def</span> <span class="nf">merge_scc_dags</span><span class="p">(</span><span class="n">l_scc</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Merge every other streams into the first one, we assume there&#39;s no connection between them</span>
<span class="sd">    and that links aren&#39;t constructed yet</span>
<span class="sd">    :param l_scc</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">scc1</span> <span class="o">=</span> <span class="n">l_scc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scc1</span><span class="o">.</span><span class="n">times</span><span class="p">:</span>
        <span class="n">min_t</span><span class="p">,</span> <span class="n">max_t</span> <span class="o">=</span> <span class="n">scc1</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scc1</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="n">l_scc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">scc1</span><span class="o">.</span><span class="n">c_nodes</span> <span class="o">+=</span> <span class="n">scc</span><span class="o">.</span><span class="n">c_nodes</span>
        <span class="k">if</span> <span class="n">scc</span><span class="o">.</span><span class="n">times</span><span class="p">:</span>
            <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_t</span><span class="p">,</span> <span class="n">scc</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_t</span><span class="p">,</span> <span class="n">scc</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">scc1</span><span class="o">.</span><span class="n">times</span><span class="p">:</span>
        <span class="n">scc1</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_t</span><span class="p">,</span> <span class="n">max_t</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">scc1</span></div>


<div class="viewcode-block" id="add_arrow"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.add_arrow">[docs]</a><span class="k">def</span> <span class="nf">add_arrow</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Thanks to : https://stackoverflow.com/questions/34017866/arrow-on-a-line-plot-with-matplotlib</span>
<span class="sd">    add an arrow to a line.</span>

<span class="sd">    line:       ((a_x,_y),(b_x,b_y))</span>
<span class="sd">    ax:         matplotlib axes</span>
<span class="sd">    direction:  &#39;left&#39; or &#39;right&#39;</span>
<span class="sd">    size:       size of the arrow in fontsize points</span>
<span class="sd">    color:      color of arrow (should be coherent with line color, or not )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                    <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;&lt;-&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">),</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                    <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                    <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span>
                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">),</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="scc_dag"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag">[docs]</a><span class="k">class</span> <span class="nc">scc_dag</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">c_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">c_links</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">id_scc_to_scc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">node_to_id_scc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">segmented_node_to_id_scc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">a_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A basic constructor for the condensation DAG</span>
<span class="sd">        :param c_nodes : A list of SCC nodes (each c node represent a SCC : a set of nodes, a begin time, an end time)</span>
<span class="sd">        :param c_links : A list of directed link (each link represent two connected SCC)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="c1"># Do not touch !</span>
        <span class="k">if</span> <span class="n">c_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="o">=</span> <span class="n">c_nodes</span>
        <span class="k">if</span> <span class="n">c_links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span> <span class="o">=</span> <span class="n">c_links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span> <span class="o">=</span> <span class="n">node_to_id_scc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span> <span class="o">=</span> <span class="n">segmented_node_to_id_scc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span> <span class="o">=</span> <span class="n">id_scc_to_scc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_l</span> <span class="o">=</span> <span class="n">a_l</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Id wcc :&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">rep</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes :&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">)</span>
        <span class="n">rep</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Links :&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rep</span>


<div class="viewcode-block" id="scc_dag.describe"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        TODO : Add multiple information</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DAG Id:&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nb of Nodes (SCC) : &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nb of stream nodes : &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">])))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nb of links : &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">))</span>
        <span class="n">stream_links</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">links</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">links</span><span class="p">:</span>
                    <span class="n">stream_links</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nb of stream links : &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stream_links</span><span class="p">))</span></div>

<div class="viewcode-block" id="scc_dag.set_index_node_to_id_scc"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.set_index_node_to_id_scc">[docs]</a>    <span class="k">def</span> <span class="nf">set_index_node_to_id_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">node_to_id_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span> <span class="o">=</span> <span class="n">node_to_id_scc</span></div>

<div class="viewcode-block" id="scc_dag.set_index_segmented_node_to_id_scc"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.set_index_segmented_node_to_id_scc">[docs]</a>    <span class="k">def</span> <span class="nf">set_index_segmented_node_to_id_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segmented_nodes</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_index_node_to_id_scc</span><span class="p">()</span>
        <span class="n">segmented_node_to_id_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">segmented_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]]:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">segmented_node_to_id_scc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span> <span class="o">=</span> <span class="n">segmented_node_to_id_scc</span></div>

<div class="viewcode-block" id="scc_dag.set_id_scc_to_scc"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.set_id_scc_to_scc">[docs]</a>    <span class="k">def</span> <span class="nf">set_id_scc_to_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">id_scc_to_scc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span> <span class="o">=</span> <span class="n">id_scc_to_scc</span></div>

<div class="viewcode-block" id="scc_dag.set_id"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.set_id">[docs]</a>    <span class="k">def</span> <span class="nf">set_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span></div>

<div class="viewcode-block" id="scc_dag.set_index_id_scc_to_scc"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.set_index_id_scc_to_scc">[docs]</a>    <span class="k">def</span> <span class="nf">set_index_id_scc_to_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span> <span class="o">=</span> <span class="n">index</span></div>

<div class="viewcode-block" id="scc_dag.add_node"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.add_nodes"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.add_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="o">+=</span> <span class="n">l</span></div>

<div class="viewcode-block" id="scc_dag.add_link"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.add_link">[docs]</a>    <span class="k">def</span> <span class="nf">add_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.store"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.store">[docs]</a>    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_file</span><span class="p">):</span>
        <span class="n">packer</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Packer</span><span class="p">(</span><span class="n">use_bin_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">packer</span><span class="o">.</span><span class="n">pack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">)))</span></div>

<div class="viewcode-block" id="scc_dag.store_links"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.store_links">[docs]</a>    <span class="k">def</span> <span class="nf">store_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="n">packer</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Packer</span><span class="p">(</span><span class="n">use_bin_type</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;scc_dag_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_links.mspk&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">packer</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">))</span></div>

<div class="viewcode-block" id="scc_dag.refactor"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.refactor">[docs]</a>    <span class="k">def</span> <span class="nf">refactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[[(</span><span class="n">cc</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cc</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cc</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">]</span></div>

<div class="viewcode-block" id="scc_dag.plot_as_nx"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.plot_as_nx">[docs]</a>    <span class="k">def</span> <span class="nf">plot_as_nx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">g_adjacency_list</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">)}</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a_l : &quot;</span><span class="p">,</span> <span class="n">g_adjacency_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">g_adjacency_list</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
            <span class="n">G_glob</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_dict_of_lists</span><span class="p">(</span><span class="n">g_adjacency_list</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">kamada_kawai_layout</span><span class="p">(</span><span class="n">G_glob</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">G_glob</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G_glob</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                   <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;#339966&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G_glob</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="s1">&#39;#2d5986&#39;</span><span class="p">,</span>
                                   <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">arrows</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.plot_custom"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.plot_custom">[docs]</a>    <span class="k">def</span> <span class="nf">plot_custom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">arrow</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">):</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">times</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">t0</span> <span class="o">+</span> <span class="n">t1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
            <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span>
            <span class="c1"># pos[i] = [x, i]</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
        <span class="n">g_adjacency_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="c1"># Plot nodes and links : plot nodes in increasing order</span>
        <span class="c1"># adjust &#39;y&#39; depending on the number of neighbors</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">E</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">g_adjacency_list</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
                    <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">pos</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BEGIN PLOT, POSITIONS CALCULATED&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="n">c</span><span class="o">=</span><span class="s2">&quot;#339966&quot;</span><span class="p">,</span>
                   <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                   <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span>
                   <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span>
                   <span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; DRAWING NODES : DONE&quot;</span><span class="p">)</span>
        <span class="n">edge_collections</span> <span class="o">=</span> <span class="n">mcol</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;#2d5986&#39;</span><span class="p">],</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arrow</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
                <span class="n">add_arrow</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#2d5986&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">edge_collections</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; DRAWING EDGES : DONE&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">min_y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#476b6b&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">place</span><span class="p">,</span><span class="n">spine</span> <span class="ow">in</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">place</span> <span class="o">!=</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;#476b6b&#39;</span><span class="p">)</span>


        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.size"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.core_number"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.core_number">[docs]</a>    <span class="k">def</span> <span class="nf">core_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">para_cores</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">):</span>
            <span class="c1"># return comp.get_kcores(storage_path)</span>
            <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">core_number</span><span class="p">()</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">para_cores</span><span class="p">)(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="scc_dag.k_core"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.k_core">[docs]</a>    <span class="k">def</span> <span class="nf">k_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">para_cores</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">k_core</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">para_cores</span><span class="p">)(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">+=</span> <span class="n">l</span>
        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="scc_dag.all_cliques"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.all_cliques">[docs]</a>    <span class="k">def</span> <span class="nf">all_cliques</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">para_cliques</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">):</span>
            <span class="c1"># return comp.get_kcliques(storage_path)</span>
            <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">all_cliques</span><span class="p">()</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">para_cliques</span><span class="p">)(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="scc_dag.k_clique"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.k_clique">[docs]</a>    <span class="k">def</span> <span class="nf">k_clique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">storage_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">para_cliques</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">):</span>
            <span class="c1"># return comp.get_kcliques(storage_path)</span>
            <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">k_clique</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)(</span>
            <span class="n">delayed</span><span class="p">(</span><span class="n">para_cliques</span><span class="p">)(</span><span class="n">comp</span><span class="p">,</span> <span class="n">storage_path</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span> <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">+=</span> <span class="n">l</span>
        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="scc_dag.get_stable_parts_inplace"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.get_stable_parts_inplace">[docs]</a>    <span class="k">def</span> <span class="nf">get_stable_parts_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">+=</span> <span class="n">comp</span><span class="o">.</span><span class="n">get_stable_parts</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="scc_dag.get_stable_dag"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.get_stable_dag">[docs]</a>    <span class="k">def</span> <span class="nf">get_stable_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Rajouter les stables parts comme des components</span>
        <span class="n">stable_DAG</span> <span class="o">=</span> <span class="n">scc_dag</span><span class="p">()</span>
        <span class="n">stable_DAG</span><span class="o">.</span><span class="n">set_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">cnt_c_nodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="n">stable_comps</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">get_stable_components</span><span class="p">()</span>
            <span class="n">stable_DAG</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">stable_comps</span><span class="p">)</span>
            <span class="n">new_cnt_c_nodes</span> <span class="o">=</span> <span class="n">cnt_c_nodes</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">stable_comps</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_cnt_c_nodes</span> <span class="o">-</span> <span class="n">cnt_c_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cnt_c_nodes</span><span class="p">,</span> <span class="n">new_cnt_c_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">stable_DAG</span><span class="o">.</span><span class="n">add_link</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cnt_c_nodes</span> <span class="o">=</span> <span class="n">new_cnt_c_nodes</span>
        <span class="k">return</span> <span class="n">stable_DAG</span></div>

<div class="viewcode-block" id="scc_dag.compute_links_inplace"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.compute_links_inplace">[docs]</a>    <span class="k">def</span> <span class="nf">compute_links_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># IF there&#39;s is some links, discard them.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dict_begin_time_to_cnodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">dict_end_time_to_cnodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="n">dict_begin_time_to_cnodes</span><span class="p">[</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">dict_end_time_to_cnodes</span><span class="p">[</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>


        <span class="c1"># # To Deal With Instantaneous Component:</span>
        <span class="c1"># instantanous_scc = set()</span>
        <span class="c1"># for cn in self.c_nodes:</span>
        <span class="c1">#     if cn.times[0] == cn.times[1]:</span>
        <span class="c1">#         instantanous_scc.add(cn.id)</span>
        <span class="c1"># links_to_instant_scc = []</span>

        <span class="c1"># For each end_time find a begin_time (if it exists) then compute the intersection of nodes</span>
        <span class="c1"># if not empty add to dag links</span>
        <span class="n">set_links</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_end_time_to_cnodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_begin_time_to_cnodes</span><span class="p">:</span>
                <span class="c1"># Double for loop in order to match pairwise</span>
                <span class="k">for</span> <span class="n">cn_parent_id</span> <span class="ow">in</span> <span class="n">dict_end_time_to_cnodes</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">cn_child_id</span> <span class="ow">in</span> <span class="n">dict_begin_time_to_cnodes</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">cn_child_id</span> <span class="o">!=</span> <span class="n">cn_parent_id</span><span class="p">:</span>
                            <span class="n">cn_child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">cn_child_id</span><span class="p">]</span>
                            <span class="n">cn_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">cn_parent_id</span><span class="p">]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">cn_child</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">cn_parent</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                                <span class="c1"># if cn_parent_id in instantanous_scc or cn_child_id in instantanous_scc:</span>
                                <span class="c1">#     links_to_instant_scc.append((cn_parent_id, cn_child_id))</span>
                                <span class="n">set_links</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">cn_parent_id</span><span class="p">,</span> <span class="n">cn_child_id</span><span class="p">))</span>

        <span class="c1">#Remove USELESS links in there are Instantaneous Components :)</span>
        <span class="c1"># if instantanous_scc:</span>
        <span class="c1">#     pred = defaultdict(set)</span>
        <span class="c1">#     suc = defaultdict(set)</span>
        <span class="c1">#     for l in links_to_instant_scc:</span>
        <span class="c1">#         u, v = l</span>
        <span class="c1">#         suc[u].add(v)</span>
        <span class="c1">#         pred[v].add(u)</span>
        <span class="c1">#     to_remove = set()</span>
        <span class="c1">#     for w in instantanous_scc:</span>
        <span class="c1">#         for p in pred[w]:</span>
        <span class="c1">#             for s in suc[w]:</span>
        <span class="c1">#                 if (p,s) in set_links:</span>
        <span class="c1">#                     to_remove.add((p,s))</span>
            <span class="c1"># for l in set_links:</span>
            <span class="c1">#     u,v = l</span>
            <span class="c1">#     if u not in instantanous_scc and v not in instantanous_scc:</span>
            <span class="c1">#         for w in instantanous_scc:</span>
            <span class="c1">#             if u in pred[w] and v in suc[w]:</span>
            <span class="c1">#                 to_remove.add(l)</span>
            <span class="c1"># set_links = set_links- to_remove</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_links</span><span class="p">)</span></div>





<div class="viewcode-block" id="scc_dag.compute_links"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.compute_links">[docs]</a>    <span class="k">def</span> <span class="nf">compute_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_scc</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="n">storage_path_scc_dag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># IF there&#39;s is some links, discard them.</span>

        <span class="n">dict_begin_time_to_cnodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">dict_end_time_to_cnodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">dict_id_set_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="c1"># Get times and set of nodes corresponding to each c_nodes</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path_scc</span><span class="p">)</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span>
            <span class="n">id_scc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
                <span class="n">unpacker</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">unpacker</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
                <span class="n">dict_begin_time_to_cnodes</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                <span class="n">dict_end_time_to_cnodes</span><span class="p">[</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unpacker</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                    <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># For each time_end_find a time_begin (if it exists) then compute the intersection of ndoes</span>
        <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_end_time_to_cnodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_begin_time_to_cnodes</span><span class="p">:</span>
                <span class="c1"># Double for loop in order to match pairwise</span>
                <span class="k">for</span> <span class="n">cn_parent</span> <span class="ow">in</span> <span class="n">dict_end_time_to_cnodes</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">cn_child</span> <span class="ow">in</span> <span class="n">dict_begin_time_to_cnodes</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_child</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_parent</span><span class="p">]):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn_parent</span><span class="p">,</span> <span class="n">cn_child</span><span class="p">))</span>
        <span class="c1"># print(&quot;C Links :&quot;,self.c_links)</span>
        <span class="k">if</span> <span class="n">storage_path_scc_dag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_links</span><span class="p">(</span><span class="n">storage_path_scc_dag</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.adjacency_list"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.adjacency_list">[docs]</a>    <span class="k">def</span> <span class="nf">adjacency_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_l</span><span class="p">:</span>
            <span class="n">a_l</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
                <span class="c1"># ONLY IF the destination is accesible from begin time</span>
                <span class="c1"># c = self.index_id_scc_to_nodes[l[1]]</span>
                <span class="c1"># if c.times[0] &gt;= threshold:</span>
                <span class="n">a_l</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a_l</span> <span class="o">=</span> <span class="n">a_l</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_l</span></div>

    <span class="c1">###############################</span>
    <span class="c1">#       Paths Methods         #</span>
    <span class="c1">###############################</span>

<div class="viewcode-block" id="scc_dag.condensation_path_as_substream"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.condensation_path_as_substream">[docs]</a>    <span class="k">def</span> <span class="nf">condensation_path_as_substream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">node_to_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">path_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform a path in the condensation dag into a substream</span>
<span class="sd">        :param path: Sequence of SCC (object) in the condensation DAG</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span> <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>

        <span class="n">new_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nodes_to_new_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_to_new_nodes</span><span class="p">))</span>
        <span class="n">new_node_to_label</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_node_to_id</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">new_links</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">t0_min</span><span class="p">,</span> <span class="n">t1_max</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span>
            <span class="k">if</span> <span class="n">path_bounds</span><span class="p">:</span>
                <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">path_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">t1</span><span class="p">)</span>
            <span class="n">t0_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t0_min</span><span class="p">)</span>
            <span class="n">t1_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1_max</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_new_nodes</span><span class="p">:</span>
                    <span class="n">new_n</span> <span class="o">=</span> <span class="n">nodes_to_new_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">new_nodes</span><span class="p">[</span><span class="n">new_n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">new_nodes</span><span class="p">[</span><span class="n">new_n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_nodes</span><span class="p">[</span><span class="n">new_n</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_n</span> <span class="o">=</span> <span class="n">nodes_to_new_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="n">new_node_to_id</span><span class="p">[</span><span class="n">new_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="k">if</span> <span class="n">node_to_label</span><span class="p">:</span>
                        <span class="n">new_node_to_label</span><span class="p">[</span><span class="n">new_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_to_label</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="n">new_nodes</span><span class="p">[</span><span class="n">new_n</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">links</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">links</span><span class="p">:</span>
                    <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t0</span>
                    <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
                    <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">new_u</span><span class="p">,</span> <span class="n">new_v</span> <span class="o">=</span> <span class="n">nodes_to_new_nodes</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">nodes_to_new_nodes</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">new_u</span><span class="p">,</span><span class="n">new_v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">new_links</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">new_links</span><span class="p">[(</span><span class="n">new_u</span><span class="p">,</span><span class="n">new_v</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">new_links</span><span class="p">[(</span><span class="n">new_u</span><span class="p">,</span><span class="n">new_v</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_links</span><span class="p">[(</span><span class="n">new_u</span><span class="p">,</span><span class="n">new_v</span><span class="p">)]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span><span class="n">t1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_links</span><span class="p">[(</span><span class="n">new_u</span><span class="p">,</span><span class="n">new_v</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">,</span><span class="n">t1</span><span class="p">]</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">stream_graph</span><span class="p">(</span><span class="n">times</span><span class="o">=</span><span class="p">[</span><span class="n">t0_min</span><span class="p">,</span> <span class="n">t1_max</span><span class="p">],</span>
                               <span class="n">nodes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                               <span class="n">node_presence</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                               <span class="n">node_to_label</span><span class="o">=</span><span class="n">new_node_to_label</span><span class="p">,</span>
                               <span class="n">node_to_id</span><span class="o">=</span><span class="n">new_node_to_id</span><span class="p">,</span>
                               <span class="n">links</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_links</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                               <span class="n">link_presence</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_links</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">F</span></div>

    <span class="c1">####################################################</span>
    <span class="c1">#   1. Source-Destination Time to reach/ Latencies #</span>
    <span class="c1">####################################################</span>
    <span class="c1"># TODO: Need to update functions in 1. with below functions in 2.</span>

<div class="viewcode-block" id="scc_dag.temporal_node_to_scc"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.temporal_node_to_scc">[docs]</a>    <span class="k">def</span> <span class="nf">temporal_node_to_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        return the Strongly Connected component containing the temporal source *node*.</span>
<span class="sd">        :param node:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">t0</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.node_to_scc"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.node_to_scc">[docs]</a>    <span class="k">def</span> <span class="nf">node_to_scc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">list_scc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">list_scc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_scc</span></div>

<div class="viewcode-block" id="scc_dag.time_to_reach"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.time_to_reach">[docs]</a>    <span class="k">def</span> <span class="nf">time_to_reach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_to_reach</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_to_reach_temporal_nodes</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_time_to_reach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="c1"># TODO : to finish</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_time_to_reach_temporal_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the time to reach the *destination* from the temporal source node *source* in the SG.</span>
<span class="sd">        :param source:</span>
<span class="sd">        :param desination:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ttr</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporal_node_to_scc</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ttr</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start comp:&quot;</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start_comp</span><span class="p">])</span>  <span class="c1"># comp</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_comp</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">destination</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ttr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ttr</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">st</span> <span class="o">+</span> <span class="n">ttr</span><span class="p">:</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ttr</span>

<div class="viewcode-block" id="scc_dag.latency"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.latency">[docs]</a>    <span class="k">def</span> <span class="nf">latency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latency</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latency_temporal_nodes</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_latency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="c1"># TODO : To finish</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_latency_temporal_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the latency between the temporal node *source* and the temporal node *destination* in the SG.</span>
<span class="sd">        :param source:</span>
<span class="sd">        :param destination:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">latency</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>  <span class="c1"># On itere sur les scc contenant source</span>
            <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">unvisited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">destination</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">latency</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">return</span> <span class="n">latency</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">start_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># starting time</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start_comp</span><span class="p">,</span> <span class="n">st</span><span class="p">)])</span>  <span class="c1"># comp, starting time</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_comp</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">comp</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1"># We can reset the starting time</span>
                <span class="k">if</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="c1"># Update latencies</span>
                <span class="k">if</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">destination</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">latency</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">latency</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">st</span> <span class="o">+</span> <span class="n">latency</span><span class="p">:</span>
                                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">st</span><span class="p">))</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">latency</span>

    <span class="c1">#####################################################</span>
    <span class="c1">#   2. Single-Source Time to reach and Latencies    #</span>
    <span class="c1">#####################################################</span>

<div class="viewcode-block" id="scc_dag.times_to_reach"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.times_to_reach">[docs]</a>    <span class="k">def</span> <span class="nf">times_to_reach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_to_reach_ss</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_to_reach_temporal_nodes_ss</span><span class="p">(</span><span class="n">source</span><span class="p">)</span></div>


<div class="viewcode-block" id="scc_dag.postprocess_ttr"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.postprocess_ttr">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess_ttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">ttr_comp</span><span class="p">):</span>
        <span class="n">ttr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">:</span>
            <span class="n">potential_ttr</span> <span class="o">=</span> <span class="p">[</span><span class="n">ttr_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ttr_comp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">potential_ttr</span><span class="p">:</span>
                <span class="n">ttr</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">potential_ttr</span><span class="p">)</span>
        <span class="n">ttr</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ttr</span></div>

    <span class="k">def</span> <span class="nf">_times_to_reach_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">id_start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># The first SCC where the source appears</span>
        <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span>
        <span class="n">ttr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_to_reach_comp_ss</span><span class="p">(</span><span class="n">id_start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">start_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ttr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_ttr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">ttr_comp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ttr</span>

    <span class="k">def</span> <span class="nf">_times_to_reach_temporal_nodes_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">potential_start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="c1"># #</span>
        <span class="c1"># if source == (1386320340.0, 1386329460.0, 1):</span>
        <span class="c1">#     for id_comp in potential_start_comp:</span>
        <span class="c1">#         if self.id_scc_to_scc[id_comp].times[0] == 1386320340.0:</span>
        <span class="c1">#             print(self.id_scc_to_scc[id_comp].nodes)</span>
        <span class="c1">#         if 236 in self.id_scc_to_scc[id_comp].nodes:</span>
        <span class="c1">#             print(self.id_scc_to_scc[id_comp].times)</span>
        <span class="c1">#</span>
        <span class="c1"># #</span>

        <span class="k">for</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">potential_start_comp</span><span class="p">:</span>
            <span class="n">comp_t0</span><span class="p">,</span> <span class="n">comp_t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span><span class="o">.</span><span class="n">times</span>
            <span class="k">if</span> <span class="n">comp_t0</span> <span class="o">&lt;=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp_t1</span><span class="p">:</span>
                <span class="n">id_start_comp</span> <span class="o">=</span> <span class="n">id_comp</span>
                <span class="k">break</span>
        <span class="n">ttr_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times_to_reach_comp_ss</span><span class="p">(</span><span class="n">id_start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="o">=</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ttr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_ttr</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ttr_comp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ttr</span>


    <span class="k">def</span> <span class="nf">_times_to_reach_comp_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_start_comp</span><span class="p">,</span> <span class="n">start_time</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the times to reach from the temporal source node :*source* to every other node in the SG.</span>
<span class="sd">        :param source:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="n">times_to_reach_comp</span> <span class="o">=</span> <span class="p">{</span><span class="n">id_start_comp</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">id_start_comp</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">id_start_comp</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">id_comp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>
            <span class="n">times_to_reach_comp</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_time</span>
            <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_id</span><span class="p">)</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">times_to_reach_comp</span>

<div class="viewcode-block" id="scc_dag.latencies"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.latencies">[docs]</a>    <span class="k">def</span> <span class="nf">latencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latencies_ss</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latencies_temporal_nodes_ss</span><span class="p">(</span><span class="n">source</span><span class="p">)</span></div>

<div class="viewcode-block" id="scc_dag.postprocess_latencies"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.postprocess_latencies">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess_latencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latencies_comp</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">latencies</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">:</span>
            <span class="n">potential_latencies</span> <span class="o">=</span> <span class="p">[</span><span class="n">latencies_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">latencies_comp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">potential_latencies</span><span class="p">:</span>
                <span class="n">latencies</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">potential_latencies</span><span class="p">)</span>
        <span class="n">latencies</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">latencies</span></div>


    <span class="k">def</span> <span class="nf">_latencies_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">ids_start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>  <span class="c1"># SCCs where the source appears</span>
        <span class="n">latencies_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latencies_comp_ss</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>
        <span class="n">latencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_latencies</span><span class="p">(</span><span class="n">latencies_comp</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">latencies</span>


    <span class="k">def</span> <span class="nf">_latencies_temporal_nodes_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="n">ids_start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>  <span class="c1"># SCC where the source appears</span>
        <span class="n">latencies_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latencies_comp_ss</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>
        <span class="n">latencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_latencies</span><span class="p">(</span><span class="n">latencies_comp</span><span class="p">,</span> <span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">latencies</span>

    <span class="k">def</span> <span class="nf">_latencies_comp_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids_start_comp</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the latencies from the temporal source node: *source* to every other node in the SG.</span>
<span class="sd">        :param source:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="n">latencies</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids_start_comp</span><span class="p">}</span>  <span class="c1"># clefs : destination nodes ; valeurs : latency</span>
        <span class="n">set_start_comps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>
        <span class="n">unvisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>
        <span class="n">visited_to_st</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#TODO : unvisited and set_start _comps necessaire ?</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">id_start_comp</span> <span class="o">=</span> <span class="n">unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># starting time</span>
            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">id_start_comp</span><span class="p">,</span> <span class="n">st</span><span class="p">)])</span>  <span class="c1"># comp, starting time</span>
            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">id_comp</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">set_start_comps</span><span class="p">:</span>
                    <span class="c1"># We can reset the starting time</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">id_comp</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">latencies</span><span class="p">:</span>
                        <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">,</span> <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span>

                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>

                        <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_to_st</span> <span class="ow">or</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]:</span>
                            <span class="c1"># TODO : Verifier que la condition s&#39;applique bien</span>

                            <span class="c1"># On ne doit pas avoir c_id plusieurs fois dans la queue !!</span>
                            <span class="c1">#Ou tester en sortie de pile !</span>
                            <span class="c1"># We leave later :)</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c_id</span><span class="p">,</span> <span class="n">st</span><span class="p">))</span>
                            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
        <span class="k">return</span> <span class="n">latencies</span>


    <span class="c1">##############################################</span>
    <span class="c1">#   3. Arbitrary Foremost and fastest Paths  #</span>
    <span class="c1">##############################################</span>

<div class="viewcode-block" id="scc_dag.foremost_path"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.foremost_path">[docs]</a>    <span class="k">def</span> <span class="nf">foremost_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute a foremost path between &#39;source&#39; and &#39;destination&quot; starting at &#39;begin time&#39;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporal_node_to_scc</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>

        <span class="c1"># Custom BFS on DAG</span>
        <span class="k">def</span> <span class="nf">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
            <span class="n">path_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start_comp</span><span class="p">,</span> <span class="p">[</span><span class="n">start_comp</span><span class="o">.</span><span class="n">id</span><span class="p">])])</span>
            <span class="n">ttr</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_comp</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
            <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
                <span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1"># print(&quot; v : &quot;,v)</span>
                <span class="c1"># print(&quot; len path queue :&quot;,len(path_queue))</span>
                <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_id</span><span class="p">)</span>
                            <span class="c1"># print(&quot; comp nodes :&quot;,comp.nodes)</span>
                            <span class="k">if</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">destination</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">destination</span><span class="p">[</span>
                                <span class="mi">1</span><span class="p">]:</span>
                                <span class="c1"># print(&quot;PATH Found :&quot;,path)</span>
                                <span class="n">ttr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ttr</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]</span>
                            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">st</span> <span class="o">+</span> <span class="n">ttr</span><span class="p">:</span>
                                <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]))</span>

        <span class="c1"># print(&quot; Start BFS&quot;)</span>
        <span class="n">foremost_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">foremost_paths</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">path_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">foremost_paths</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span>
                <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">path_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># print(&quot;Path times :&quot;, path_times)</span>
        <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path_times</span><span class="p">])</span>
        <span class="c1"># print(&quot;Foremost time : &quot;, min_t)</span>
        <span class="n">fm_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">,</span> <span class="n">path_times</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_t</span><span class="p">:</span>
                <span class="n">fm_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fm_paths</span><span class="p">,</span> <span class="n">min_t</span> <span class="o">-</span> <span class="n">st</span></div>

<div class="viewcode-block" id="scc_dag.fastest_path"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.fastest_path">[docs]</a>    <span class="k">def</span> <span class="nf">fastest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute the fastest path between &#39;source&#39; and &#39;destination&#39;</span>
<span class="sd">        :param source:</span>
<span class="sd">        :param destination:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="n">ids_start_comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
        <span class="n">unvisited</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>  <span class="c1"># SCC where the source appears</span>
        <span class="n">visited_to_st</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">latency</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">fastest_paths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">id_start_comp</span> <span class="o">=</span> <span class="n">unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">start_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># starting time</span>
            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
            <span class="n">path_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([((</span><span class="n">id_start_comp</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="p">[</span><span class="n">id_start_comp</span><span class="p">])])</span> <span class="c1">#((id comp, start time),path)</span>
            <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
                <span class="n">e</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">id_comp</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">ids_start_comp</span><span class="p">:</span>
                    <span class="c1"># We can reset the starting time</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">id_comp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">destination</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">new_latency</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_latency</span> <span class="o">&lt;</span> <span class="n">latency</span><span class="p">:</span>
                        <span class="n">fastest_paths</span> <span class="o">=</span> <span class="n">path</span>
                        <span class="n">latency</span> <span class="o">=</span> <span class="n">new_latency</span>

                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_to_st</span><span class="p">:</span>
                            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
                            <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">c_id</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]))</span>
                        <span class="k">elif</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]:</span>
                            <span class="c1"># We leave later :)</span>
                            <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">c_id</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]))</span>
                            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
        <span class="k">return</span> <span class="n">fastest_paths</span><span class="p">,</span> <span class="n">latency</span></div>



    <span class="c1">############################################</span>
    <span class="c1">#   4. All foremost path and fastest paths #</span>
    <span class="c1">############################################</span>

<div class="viewcode-block" id="scc_dag.compute_all_foremost_paths"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.compute_all_foremost_paths">[docs]</a>    <span class="k">def</span> <span class="nf">compute_all_foremost_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">,</span> <span class="n">index_node_to_scc</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">duration_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_comp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute a foremost path between &#39;source&#39; and &#39;destination&quot; starting at &#39;begin time&#39;.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print(&quot;Foremost path from &quot;, source, &quot; to &quot;, destination, &quot; starting at time &quot;, start)</span>

        <span class="c1"># Get starting component</span>
        <span class="k">if</span> <span class="n">start_comp</span><span class="p">:</span>
            <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="n">start_comp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">id_wcc</span><span class="p">,</span> <span class="n">start_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_node_to_scc</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
                <span class="n">id_wcc</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">[[</span><span class="n">id_scc</span><span class="p">]],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id_wcc</span>
                    <span class="n">start_comp</span> <span class="o">=</span> <span class="n">id_scc</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">start_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Node : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; does not exist in the Stream Graph at time &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; !&quot;</span><span class="p">)</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">end_time_comp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">c_links</span><span class="p">:</span>
                <span class="c1"># ONLY IF the destination is accesible from begin time</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">a_l</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">end_time_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">duration_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">end_time_comp</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">duration_threshold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">end_time_comp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span>

        <span class="c1"># print(&quot;duration threshold :&quot;,duration_threshold)</span>
        <span class="c1"># print(&quot; a_l : &quot;, a_l)</span>

        <span class="c1"># Custom BFS on DAG</span>
        <span class="k">def</span> <span class="nf">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
            <span class="n">path_queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_comp</span><span class="p">,</span> <span class="p">[</span><span class="n">start_comp</span><span class="p">])]</span>
            <span class="n">foremost_duration</span> <span class="o">=</span> <span class="n">duration_threshold</span>  <span class="c1"># This variable, once assigned, is used as a threshold (yeah)</span>
            <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
                <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># print(&quot; v : &quot;,v)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; len path queue :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_queue</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                        <span class="n">comp</span> <span class="o">=</span> <span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; comp id :&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; comp times :&quot;</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                            <span class="c1"># print(&quot;PATH Found :&quot;,path)</span>
                            <span class="n">foremost_duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">foremost_duration</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                            <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
                            <span class="c1"># return path + [c]</span>
                        <span class="k">elif</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">foremost_duration</span><span class="p">:</span>
                            <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="p">]))</span>

        <span class="c1"># print(&quot; Start BFS&quot;)</span>
        <span class="n">foremost_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bfs_scc</span><span class="p">(</span><span class="n">a_l</span><span class="p">,</span> <span class="n">start_comp</span><span class="p">,</span> <span class="n">destination</span><span class="p">))</span>
        <span class="c1">#</span>
        <span class="c1"># foremost_path = bfs_scc(a_l, start_comp, destination)</span>
        <span class="c1"># if foremost_path:</span>
        <span class="c1">#     return [foremost_path],dict_id_wcc_to_dag[id_wcc].index_id_scc_to_nodes[foremost_path[-1]].times[0]-start,id_wcc</span>
        <span class="c1"># else:</span>
        <span class="c1">#     return None, None, None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">foremost_paths</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">path_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">foremost_paths</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dict_id_wcc_to_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">path_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># print(&quot;Path times :&quot;, path_times)</span>
        <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path_times</span><span class="p">])</span>
        <span class="c1"># print(&quot;Foremost time : &quot;, min_t)</span>
        <span class="n">fm_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">foremost_paths</span><span class="p">,</span> <span class="n">path_times</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_t</span><span class="p">:</span>
                <span class="n">fm_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fm_paths</span><span class="p">,</span> <span class="n">min_t</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">id_wcc</span></div>


<div class="viewcode-block" id="scc_dag.all_fastest_paths"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.all_fastest_paths">[docs]</a>    <span class="k">def</span> <span class="nf">all_fastest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">destination</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute the fastest path between &#39;source&#39; and &#39;destination&#39;</span>
<span class="sd">        :param source:</span>
<span class="sd">        :param destination:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="n">ids_start_comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
        <span class="n">unvisited</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>  <span class="c1"># SCC where the source appears</span>
        <span class="n">visited_to_st</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#We store visited component along with the starting time corresponding with the path that reached them;</span>
        <span class="n">latency</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">fastest_paths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">id_start_comp</span> <span class="o">=</span> <span class="n">unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">start_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># starting time</span>
            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
            <span class="n">path_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([((</span><span class="n">id_start_comp</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="p">[</span><span class="n">id_start_comp</span><span class="p">])])</span> <span class="c1">#((id comp, start time),path)</span>
            <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
                <span class="n">e</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">id_comp</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">ids_start_comp</span><span class="p">:</span>
                    <span class="c1"># We can reset the starting time</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">id_comp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">and</span> <span class="n">destination</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">destination</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">new_latency</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_latency</span> <span class="o">&lt;</span> <span class="n">latency</span><span class="p">:</span>
                        <span class="n">fastest_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
                        <span class="n">latency</span> <span class="o">=</span> <span class="n">new_latency</span>
                    <span class="k">elif</span> <span class="n">new_latency</span> <span class="o">==</span> <span class="n">latency</span><span class="p">:</span>
                        <span class="n">fastest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_to_st</span><span class="p">:</span>
                            <span class="c1"># We haven&#39;t seen the comp :)</span>
                            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
                            <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">c_id</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]))</span>
                        <span class="k">elif</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]:</span>
                            <span class="c1"># We leave later :)</span>
                            <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">c_id</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]))</span>
                            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
        <span class="k">return</span> <span class="n">fastest_paths</span><span class="p">,</span> <span class="n">latency</span></div>



<div class="viewcode-block" id="scc_dag.all_fastest_paths_ss"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.all_fastest_paths_ss">[docs]</a>    <span class="k">def</span> <span class="nf">all_fastest_paths_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute the fastest path between &#39;source&#39; and all other nodes (in condensation DAG)</span>

<span class="sd">        :param source:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_list</span><span class="p">()</span>
        <span class="n">ids_start_comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segmented_node_to_id_scc</span><span class="p">[</span><span class="n">source</span><span class="p">])</span>
        <span class="n">unvisited</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ids_start_comp</span><span class="p">)</span>  <span class="c1"># SCC where the source appears</span>
        <span class="n">visited_to_st</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#We store visited component along with the starting time corresponding with the path that reached them;</span>
        <span class="n">latencies</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids_start_comp</span><span class="p">}</span>  <span class="c1"># keys : destination nodes ;values : latency</span>
        <span class="n">fastest_paths</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:[[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids_start_comp</span><span class="p">}</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unvisited</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">id_start_comp</span> <span class="o">=</span> <span class="n">unvisited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">start_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">start_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># starting time</span>
            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">id_start_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
            <span class="n">path_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([((</span><span class="n">id_start_comp</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="p">[</span><span class="n">id_start_comp</span><span class="p">])])</span> <span class="c1">#((id comp, start time),path)</span>
            <span class="k">while</span> <span class="n">path_queue</span><span class="p">:</span>
                <span class="n">e</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">path_queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">id_comp</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">ids_start_comp</span><span class="p">:</span>
                    <span class="c1"># We can reset the starting time</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">id_comp</span><span class="p">]</span>
                    <span class="n">unvisited</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">id_comp</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">latencies</span> <span class="ow">and</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span> <span class="o">&lt;=</span> <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>

                        <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">st</span> <span class="o">==</span> <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                            <span class="n">fastest_paths</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span>
                            <span class="n">fastest_paths</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">latencies</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">st</span>
                        <span class="n">fastest_paths</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">id_comp</span> <span class="ow">in</span> <span class="n">a_l</span> <span class="ow">and</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">c_id</span> <span class="ow">in</span> <span class="n">a_l</span><span class="p">[</span><span class="n">id_comp</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">c_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_to_st</span> <span class="ow">or</span> <span class="n">st</span> <span class="o">&gt;</span> <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]:</span>
                            <span class="c1"># We haven&#39;t seen the comp :)</span>
                            <span class="n">visited_to_st</span><span class="p">[</span><span class="n">c_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
                            <span class="n">path_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">c_id</span><span class="p">,</span> <span class="n">st</span><span class="p">),</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">c_id</span><span class="p">]))</span>

        <span class="n">fastest_paths_nodes</span><span class="p">,</span> <span class="n">latencies_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postprocess_fastest_paths</span><span class="p">(</span><span class="n">fastest_paths</span><span class="p">,</span><span class="n">latencies</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">fastest_paths_nodes</span><span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">fastest_paths_nodes</span><span class="p">,</span> <span class="n">latencies_nodes</span></div>

<div class="viewcode-block" id="scc_dag.postprocess_fastest_paths"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.postprocess_fastest_paths">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess_fastest_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fastest_paths_comp</span><span class="p">,</span><span class="n">latencies_comp</span><span class="p">):</span>
        <span class="c1">#FP and Latencies in DAG to FP and Lat in Stream :</span>
        <span class="n">latencies_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">fastest_paths_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_id_scc</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">latencies_comp</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">latencies_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lat</span><span class="p">:</span>
                        <span class="n">fastest_paths_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fastest_paths_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">latencies_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">latencies_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                        <span class="n">lat</span> <span class="o">=</span> <span class="n">latencies_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">latencies_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">lat</span><span class="p">:</span>
                        <span class="n">fastest_paths_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fastest_paths_comp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fastest_paths_nodes</span><span class="p">,</span><span class="n">latencies_nodes</span></div>
    <span class="c1">###############################################</span>
    <span class="c1">#   5. Shortest Fastest Path                  #</span>
    <span class="c1">#    (Hybrids Methods)                        #</span>
    <span class="c1">###############################################</span>

<div class="viewcode-block" id="scc_dag.shortest_fastest_path"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.shortest_fastest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_fastest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">destination</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        TODO : FINISH</span>
<span class="sd">        :param source:</span>
<span class="sd">        :param destination:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">latencies</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">list_fp</span><span class="p">,</span><span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_fastest_path</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
        <span class="n">latencies</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span>
        <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">list_fp</span><span class="p">:</span>
            <span class="n">substream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condensation_path_as_substream</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">substream</span><span class="o">.</span><span class="n">distances</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">destination</span><span class="p">],</span><span class="n">lengths</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">latencies</span><span class="p">,</span><span class="n">lengths</span></div>


<div class="viewcode-block" id="scc_dag.shortest_fastest_path_ss"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.shortest_fastest_path_ss">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_fastest_path_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        TODO: FINISH</span>
<span class="sd">        :param source:</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">fastest_paths_nodes</span><span class="p">,</span><span class="n">latencies_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_fastest_paths_ss</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">lengths</span><span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">fastest_paths_nodes</span><span class="p">:</span>
            <span class="n">list_fp</span> <span class="o">=</span> <span class="n">fastest_paths_nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">list_fp</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fp :&quot;</span><span class="p">,</span><span class="n">fp</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;destination :&quot;</span><span class="p">,</span><span class="n">destination</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nodes</span>
                <span class="k">assert</span> <span class="n">destination</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">nodes</span>

                <span class="c1"># If length of the cdag path &gt; 1 : last time of the first comp; first time of the last comp</span>
                <span class="c1"># Because they are SCC and all stream nodes are reachables at any instant.</span>
                <span class="n">path_bounds</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">path_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path_bounds :&quot;</span><span class="p">,</span><span class="n">path_bounds</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;latencies destination :&quot;</span><span class="p">,</span><span class="n">latencies_nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
                    <span class="k">assert</span> <span class="n">path_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">path_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">latencies_nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">latencies_nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path_bounds :&quot;</span><span class="p">,</span><span class="n">path_bounds</span><span class="p">)</span>
                <span class="n">substream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condensation_path_as_substream</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span><span class="n">path_bounds</span><span class="o">=</span><span class="n">path_bounds</span><span class="p">)</span> <span class="c1">#Get Substream for DAG paths</span>
                <span class="n">stream_node_to_substream_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span> <span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">substream</span><span class="o">.</span><span class="n">node_to_id</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="c1">#Get source in Substream</span>
                <span class="n">b</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
                <span class="n">npres</span> <span class="o">=</span> <span class="n">substream</span><span class="o">.</span><span class="n">node_presence</span><span class="p">[</span><span class="n">stream_node_to_substream_node</span><span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
                <span class="k">for</span> <span class="n">nt0</span><span class="p">,</span><span class="n">nt1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">npres</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span><span class="n">npres</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">nt0</span><span class="o">&lt;=</span><span class="n">nt1</span><span class="o">&lt;=</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">b</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="n">nt0</span><span class="p">,</span><span class="n">nt1</span>
                        <span class="k">break</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Source in stream :&quot;</span><span class="p">,</span><span class="n">source</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Source in substream :&quot;</span><span class="p">,(</span><span class="n">b</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">stream_node_to_substream_node</span><span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
                <span class="c1"># substream.plot()</span>
                <span class="c1"># plt.show()</span>
                <span class="c1">#Compute distances in Substream</span>
                <span class="n">L</span><span class="p">,</span><span class="n">D</span> <span class="o">=</span> <span class="n">substream</span><span class="o">.</span><span class="n">latencies_and_lengths</span><span class="p">(((</span><span class="n">b</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">stream_node_to_substream_node</span><span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]])))</span>
                <span class="c1"># D = substream.distances(((b, e, stream_node_to_substream_node[source[2]])))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Latency in substream :&quot;</span><span class="p">,</span><span class="n">L</span><span class="p">[</span><span class="n">stream_node_to_substream_node</span><span class="p">[</span><span class="n">destination</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Latency in Stream :&quot;</span><span class="p">,</span><span class="n">latencies_nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">L</span><span class="p">[</span><span class="n">stream_node_to_substream_node</span><span class="p">[</span><span class="n">destination</span><span class="p">]]</span> <span class="o">==</span> <span class="n">latencies_nodes</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span>
                <span class="n">lengths</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">destination</span><span class="p">],</span><span class="n">D</span><span class="p">[</span><span class="n">stream_node_to_substream_node</span><span class="p">[</span><span class="n">destination</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Length SFP HYBRID :&quot;</span><span class="p">,</span><span class="n">lengths</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">latencies_nodes</span><span class="p">,</span><span class="n">lengths</span></div>

    <span class="c1">################### END PATHS #################################</span>

    <span class="c1">#########################################</span>
    <span class="c1">#       Plot Functions                  #</span>
    <span class="c1">#########################################</span>

<div class="viewcode-block" id="scc_dag.plot_foremost_path"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.plot_foremost_path">[docs]</a>    <span class="k">def</span> <span class="nf">plot_foremost_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ttr</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                           <span class="n">col</span><span class="o">=</span><span class="s2">&quot;#8f246b&quot;</span><span class="p">,</span> <span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draw a path on the Stream Graph S</span>
<span class="sd">        :param S: A Stream Graph</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span> <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>

        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condensation_path_as_substream</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="n">label_nodes_by_letters</span><span class="p">)</span>
        <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#4d79ff&#39;</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#00cc00&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">col</span>
                <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                                   <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                                   <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                   <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                                   <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                                   <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span>
                                                   <span class="p">))</span>
            <span class="c1"># Plot a single rectangle for COMP</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
                                               <span class="p">))</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># Plot temporal source and temporal destination</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000099&#39;</span><span class="p">,</span>
                 <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ttr</span><span class="p">],</span> <span class="p">[</span><span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#004d00&#39;</span><span class="p">,</span>
                 <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Foremost Path from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>

<div class="viewcode-block" id="scc_dag.plot_fastest_path"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.plot_fastest_path">[docs]</a>    <span class="k">def</span> <span class="nf">plot_fastest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">latency</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span>
                          <span class="n">col</span><span class="o">=</span><span class="s2">&quot;#8f246b&quot;</span><span class="p">,</span> <span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Draw a path on the Stream Graph S</span>
<span class="sd">        :param S: A Stream Graph</span>
<span class="sd">        :return:</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id_scc_to_scc</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span> <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condensation_path_as_substream</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label_nodes_by_letters</span><span class="o">=</span><span class="n">label_nodes_by_letters</span><span class="p">)</span>
        <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#4d79ff&#39;</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;#00cc00&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">col</span>

                <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mf">0.15</span><span class="p">),</span>
                                                   <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                                   <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                   <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                                   <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                                   <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span>
                                                   <span class="p">))</span>
            <span class="c1"># Plot a single rectangle for COMP</span>
            <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.15</span><span class="p">),</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">edgecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                               <span class="n">facecolor</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                               <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
                                               <span class="p">))</span>
        <span class="n">source_comp</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="c1"># Plot temporal source and temporal destination</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000099&#39;</span><span class="p">,</span>
                 <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">source_comp</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">latency</span><span class="p">],</span> <span class="p">[</span><span class="n">destination</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#004d00&#39;</span><span class="p">,</span>
                 <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Fastest Path from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span></div>

<div class="viewcode-block" id="scc_dag.refactor_path"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.refactor_path">[docs]</a>    <span class="k">def</span> <span class="nf">refactor_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_comp</span><span class="p">,</span> <span class="n">path_times</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path comp :&quot;</span><span class="p">,</span> <span class="n">path_comp</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path Time :&quot;</span><span class="p">,</span> <span class="n">path_times</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">path</span><span class="p">([],</span> <span class="p">[])</span>
        <span class="n">cur_node</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path_comp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current comp:&quot;</span><span class="p">,</span> <span class="n">path_comp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Next comp:&quot;</span><span class="p">,</span> <span class="n">path_comp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">cur_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">[</span><span class="n">path_comp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">next_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">[</span><span class="n">path_comp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">intersec_nodes</span> <span class="o">=</span> <span class="n">cur_comp</span><span class="o">.</span><span class="n">nodes</span> <span class="o">&amp;</span> <span class="n">next_comp</span><span class="o">.</span><span class="n">nodes</span>
            <span class="k">if</span> <span class="n">cur_node</span> <span class="ow">in</span> <span class="n">intersec_nodes</span><span class="p">:</span>
                <span class="c1"># No need to jump</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">intersec_nodes</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Intersec_nodes :&quot;</span><span class="p">,</span> <span class="n">intersec_nodes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;current node :&quot;</span><span class="p">,</span> <span class="n">cur_node</span><span class="p">,</span> <span class="s2">&quot; next node:&quot;</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)</span>
            <span class="n">path_inside_comp</span> <span class="o">=</span> <span class="n">cur_comp</span><span class="o">.</span><span class="n">random_path</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;path_inside_comp&quot;</span><span class="p">,</span> <span class="n">path_inside_comp</span><span class="p">)</span>
            <span class="n">cur_node</span> <span class="o">=</span> <span class="n">next_node</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">P</span><span class="o">.</span><span class="n">add_link</span><span class="p">((</span><span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">path_times</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">()</span>
        <span class="n">path_inside_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">[</span><span class="n">path_comp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">random_path</span><span class="p">(</span><span class="n">cur_node</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="o">.</span><span class="n">add_link</span><span class="p">((</span><span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">path_inside_comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;path times :&quot;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;path nodes :&quot;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="scc_dag.plot"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.scc_dag.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">saving_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">node_to_label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unique_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">min_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">icol</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">colors</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)),</span>
                                                       <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                       <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="p">,</span>
                                                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                                       <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span>
                                                       <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
                                                       <span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)),</span>
                                                       <span class="n">width</span><span class="o">=</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">height</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span><span class="p">,</span>
                                                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                                       <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span>
                                                       <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span>
                                                       <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)),</span>
                                                       <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                       <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                                       <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span>
                                                       <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span>
                                                       <span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)),</span>
                                                       <span class="n">width</span><span class="o">=</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                       <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                                       <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span>
                                                       <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span>
                                                       <span class="p">))</span>
            <span class="n">icol</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">])))</span>
            <span class="n">unique_nodes</span> <span class="o">|=</span> <span class="n">cn</span><span class="o">.</span><span class="n">nodes</span>
            <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_t</span><span class="p">,</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_t</span><span class="p">,</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">icol</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rectangles</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get_xy</span><span class="p">()</span>
            <span class="n">cx</span> <span class="o">=</span> <span class="n">rx</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">eps</span>
            <span class="n">cy</span> <span class="o">=</span> <span class="n">ry</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span>
                        <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">icol</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">icol</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rectangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cn</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">),</span>
                                                           <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                           <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                           <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                                           <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span>
                                                           <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span>
                                                           <span class="p">))</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rectangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpatch</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">),</span>
                                                           <span class="n">width</span><span class="o">=</span><span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cn</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                           <span class="n">height</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                           <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                                                           <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">icol</span><span class="p">),</span>
                                                           <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span>
                                                           <span class="p">))</span>
            <span class="n">icol</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rectangles</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">min_t</span><span class="p">,</span> <span class="n">max_t</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># if label_nodes_by_letters == True and len(unique_nodes) &lt;= 26:</span>
        <span class="c1">#     plt.yticks(range(len(unique_nodes)), ascii_uppercase[0:len(unique_nodes)], fontname=&#39;Ubuntu&#39;,</span>
        <span class="c1">#                fontsize=12, color=&#39;#666699&#39;)</span>
        <span class="k">if</span> <span class="n">node_to_label</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">)),</span>
                       <span class="p">[</span><span class="n">node_to_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">))],</span>
                       <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span>
                       <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#666699&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">)),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">)),</span>
                       <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#666699&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">min_t</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
                   <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#476b6b&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Nodes&quot;</span><span class="p">,</span> <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#666699&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#476b6b&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">fontname</span><span class="o">=</span><span class="s1">&#39;Ubuntu&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">place</span><span class="p">,</span><span class="n">spine</span> <span class="ow">in</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">spines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">place</span> <span class="o">!=</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">spine</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;#476b6b&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">saving_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">saving_path</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">format</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="compute_links_scf"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.compute_links_scf">[docs]</a><span class="k">def</span> <span class="nf">compute_links_scf</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">dict_scc_dag</span><span class="p">,</span> <span class="n">storage_path_scc_dag</span><span class="p">):</span>
    <span class="n">id_wcc_old</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cnt_lines</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">t_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">dict_scc_to_lineno</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dict_begin_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dict_end_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_scf</span> <span class="o">+</span> <span class="s1">&#39;scc.parquet&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path_scc_dag</span> <span class="o">+</span> <span class="s1">&#39;scc_dag_with_links.scf&#39;</span><span class="p">,</span>
                                                                 <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
        <span class="n">pq_reader</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatchFileReader</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="n">n_scc</span> <span class="o">=</span> <span class="n">pq_reader</span><span class="o">.</span><span class="n">num_record_batches</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N SCC :&quot;</span><span class="p">,</span> <span class="n">n_scc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_scc</span><span class="p">):</span>  <span class="c1"># SCC components are ordered by their end time</span>
            <span class="n">current_batch</span> <span class="o">=</span> <span class="n">pq_reader</span><span class="o">.</span><span class="n">get_batch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">to_pydict</span><span class="p">()</span>
            <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span> <span class="o">=</span> <span class="n">current_batch</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">current_batch</span><span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">links</span> <span class="o">=</span> <span class="n">current_batch</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">id_wcc_old</span><span class="p">:</span>  <span class="c1"># INIT</span>
                    <span class="n">id_wcc_old</span> <span class="o">=</span> <span class="n">id_wcc</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">id_wcc</span> <span class="o">%</span> <span class="mi">100000</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">id_wcc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">id_scc</span> <span class="o">%</span> <span class="mi">100000</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">id_scc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id wcc :&quot;</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="s2">&quot;id scc :&quot;</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;scc :&quot;</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="p">),</span> <span class="s2">&quot; t :&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_begin</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">id_wcc</span> <span class="o">!=</span> <span class="n">id_wcc_old</span><span class="p">:</span>
                    <span class="c1"># When we change of wcc we reset data structure</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc_old</span><span class="p">]</span>
                    <span class="c1"># For each time_end_find a time_begin (if it exists) then compute the intersection of nodes</span>
                    <span class="c1"># print(&quot;end times :&quot;,dict_end_times_to_scc)</span>
                    <span class="c1"># print(&quot;begin times :&quot;,dict_begin_times_to_scc)</span>
                    <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">:</span>
                            <span class="c1"># CATCH nodes in scc for dict_end_times_to_cnodes[te] and dict_begin_times_to_cnodes[te]</span>
                            <span class="n">list_current_scc</span> <span class="o">=</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span> <span class="o">+</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span>
                            <span class="n">dict_id_set_nodes</span> <span class="o">=</span> <span class="n">load_sccs_from_lineno</span><span class="p">(</span><span class="n">pq_reader</span><span class="p">,</span> <span class="n">list_current_scc</span><span class="p">,</span> <span class="n">dict_scc_to_lineno</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">cn_parent</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                                <span class="k">for</span> <span class="n">cn_child</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span>
                                    <span class="n">te</span><span class="p">]:</span>  <span class="c1"># Double for loop in order to match pairwise</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_child</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_parent</span><span class="p">]):</span>
                                        <span class="n">S</span><span class="o">.</span><span class="n">c_links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn_parent</span><span class="p">,</span> <span class="n">cn_child</span><span class="p">))</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>  <span class="c1"># Store the dag.</span>
                    <span class="c1"># print(&quot;STORE S :&quot;, id_wcc_old)</span>
                    <span class="k">del</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc_old</span><span class="p">]</span>
                    <span class="n">id_wcc_old</span> <span class="o">=</span> <span class="n">id_wcc</span>
                    <span class="n">dict_scc_to_lineno</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">dict_begin_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                    <span class="n">dict_end_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

                <span class="n">dict_scc_to_lineno</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt_lines</span>
                <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">t0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>

            <span class="n">cnt_lines</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LAST ITERATION :&quot;</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
            <span class="c1"># For each time_end_find a time_begin (if it exists) then compute the intersection of ndoes</span>
            <span class="c1"># print(&quot;end times :&quot;, dict_end_times_to_scc)</span>
            <span class="c1"># print(&quot;begin times :&quot;, dict_begin_times_to_scc)</span>
            <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">:</span>
                    <span class="c1"># CATCH nodes in scc for dict_end_times_to_cnodes[te] and dict_begin_times_to_cnodes[te]</span>
                    <span class="n">list_current_scc</span> <span class="o">=</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span> <span class="o">+</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span>
                    <span class="n">dict_id_set_nodes</span> <span class="o">=</span> <span class="n">load_sccs_from_lineno</span><span class="p">(</span><span class="n">pq_reader</span><span class="p">,</span> <span class="n">list_current_scc</span><span class="p">,</span> <span class="n">dict_scc_to_lineno</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cn_parent</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">cn_child</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>  <span class="c1"># Double for loop in order to match pairwise</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_child</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_parent</span><span class="p">]):</span>
                                <span class="n">S</span><span class="o">.</span><span class="n">c_links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn_parent</span><span class="p">,</span> <span class="n">cn_child</span><span class="p">))</span>
            <span class="n">S</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORE S :&quot;</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_sccs_from_lineno"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.load_sccs_from_lineno">[docs]</a><span class="k">def</span> <span class="nf">load_sccs_from_lineno</span><span class="p">(</span><span class="n">pq_reader</span><span class="p">,</span> <span class="n">list_current_scc</span><span class="p">,</span> <span class="n">dict_scc_to_lineno</span><span class="p">):</span>
    <span class="n">dict_id_set_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">list_current_scc</span><span class="p">:</span>
        <span class="n">current_batch</span> <span class="o">=</span> <span class="n">pq_reader</span><span class="o">.</span><span class="n">get_batch</span><span class="p">(</span><span class="n">dict_scc_to_lineno</span><span class="p">[</span><span class="n">id_scc</span><span class="p">])</span><span class="o">.</span><span class="n">to_pydict</span><span class="p">()</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">current_batch</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
            <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dict_id_set_nodes</span></div>


<div class="viewcode-block" id="compute_links_msgpack"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.compute_links_msgpack">[docs]</a><span class="k">def</span> <span class="nf">compute_links_msgpack</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">dict_scc_dag</span><span class="p">,</span> <span class="n">storage_path_scc_dag</span><span class="p">):</span>
    <span class="n">t_begin</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">id_wcc_old</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dict_begin_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">dict_end_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">scc_2_offset</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1">##############</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="c1">#############</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_scc_scf</span> <span class="o">+</span> <span class="s1">&#39;scc.scf&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_path_scc_dag</span> <span class="o">+</span> <span class="s1">&#39;scc_dag_with_links.scf&#39;</span><span class="p">,</span>
                                                             <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_file</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># SCC components are ordered by their end time</span>
            <span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">id_wcc_old</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># INIT</span>
                    <span class="n">id_wcc_old</span> <span class="o">=</span> <span class="n">id_wcc</span>
                <span class="k">if</span> <span class="n">id_wcc</span> <span class="o">%</span> <span class="mi">100000</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">id_scc</span> <span class="o">%</span> <span class="mi">100000</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">id_scc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;id wcc :&quot;</span><span class="p">,</span> <span class="n">id_wcc</span><span class="p">,</span> <span class="s2">&quot;id scc :&quot;</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;scc :&quot;</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="s2">&quot; t :&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_begin</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">id_wcc</span> <span class="o">!=</span> <span class="n">id_wcc_old</span><span class="p">:</span>
                    <span class="c1"># When we change of wcc we reset data structure</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc_old</span><span class="p">]</span>
                    <span class="c1"># For each time_end_find a time_begin (if it exists) then compute the intersection of nodes</span>
                    <span class="c1"># print(&quot;end times :&quot;,dict_end_times_to_scc)</span>
                    <span class="c1"># print(&quot;begin times :&quot;,dict_begin_times_to_scc)</span>
                    <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">:</span>
                            <span class="c1"># CATCH nodes in scc for dict_end_times_to_cnodes[te] and dict_begin_times_to_cnodes[te]</span>
                            <span class="n">list_current_scc</span> <span class="o">=</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span> <span class="o">+</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span>
                            <span class="n">dict_id_set_nodes</span> <span class="o">=</span> <span class="n">load_set_nodes_from_msgpack</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">list_current_scc</span><span class="p">,</span>
                                                                            <span class="n">scc_2_offset</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">cn_parent</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                                <span class="k">for</span> <span class="n">cn_child</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span>
                                    <span class="n">te</span><span class="p">]:</span>  <span class="c1"># Double for loop in order to match pairwise</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_child</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_parent</span><span class="p">]):</span>
                                        <span class="n">S</span><span class="o">.</span><span class="n">c_links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn_parent</span><span class="p">,</span> <span class="n">cn_child</span><span class="p">))</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>  <span class="c1"># Store the dag.</span>
                    <span class="c1"># print(&quot;STORE S :&quot;, id_wcc_old)</span>
                    <span class="k">del</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc_old</span><span class="p">]</span>
                    <span class="n">id_wcc_old</span> <span class="o">=</span> <span class="n">id_wcc</span>
                    <span class="n">dict_begin_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                    <span class="n">dict_end_times_to_scc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                    <span class="n">scc_2_offset</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="n">scc_2_offset</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
                <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">t0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>
                <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_scc</span><span class="p">)</span>

            <span class="n">offset</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="c1"># print(&quot;LAST ITERATION :&quot;, id_wcc)</span>
        <span class="k">if</span> <span class="n">id_wcc</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span>
            <span class="c1"># For each time_end_find a time_begin (if it exists) then compute the intersection of ndoes</span>
            <span class="c1"># print(&quot;end times :&quot;, dict_end_times_to_scc)</span>
            <span class="c1"># print(&quot;begin times :&quot;, dict_begin_times_to_scc)</span>
            <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">:</span>
                    <span class="c1"># print(&quot;current time :&quot;,te)</span>
                    <span class="c1"># CATCH nodes in scc for dict_end_times_to_cnodes[te] and dict_begin_times_to_cnodes[te]</span>
                    <span class="n">list_current_scc</span> <span class="o">=</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span> <span class="o">+</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]</span>
                    <span class="c1"># print(&quot;Current SCC :&quot;,list_current_scc)</span>
                    <span class="n">dict_id_set_nodes</span> <span class="o">=</span> <span class="n">load_set_nodes_from_msgpack</span><span class="p">(</span><span class="n">path_scc_scf</span><span class="p">,</span> <span class="n">list_current_scc</span><span class="p">,</span> <span class="n">scc_2_offset</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cn_parent</span> <span class="ow">in</span> <span class="n">dict_end_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">cn_child</span> <span class="ow">in</span> <span class="n">dict_begin_times_to_scc</span><span class="p">[</span><span class="n">te</span><span class="p">]:</span>  <span class="c1"># Double for loop in order to match pairwise</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_child</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">dict_id_set_nodes</span><span class="p">[</span><span class="n">cn_parent</span><span class="p">]):</span>
                                <span class="n">S</span><span class="o">.</span><span class="n">c_links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cn_parent</span><span class="p">,</span> <span class="n">cn_child</span><span class="p">))</span>
            <span class="n">S</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
            <span class="c1"># print(&quot;STORE S :&quot;, id_wcc)</span>
        <span class="c1">##############</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span></div>
        <span class="c1">##############</span>


<div class="viewcode-block" id="load_scc_from_msgpack"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.load_scc_from_msgpack">[docs]</a><span class="k">def</span> <span class="nf">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">scc_storage</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">):</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">scc_storage</span> <span class="o">+</span> <span class="s1">&#39;scc.scf&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_input</span><span class="p">:</span>
        <span class="n">file_input</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">dict_offset</span><span class="p">[(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">file_input</span><span class="p">,</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
        <span class="c1"># print(&quot;i :&quot;, i)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">scc</span><span class="o">.</span><span class="n">strongly_connected_component</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">id_scc</span><span class="p">,</span>
                                            <span class="n">times</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                                            <span class="n">nodes</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">u</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]]),</span>
                                            <span class="n">links</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span></div>


<div class="viewcode-block" id="load_set_nodes_from_msgpack"><a class="viewcode-back" href="../../../straph.dag.html#straph.dag.condensation_dag.load_set_nodes_from_msgpack">[docs]</a><span class="k">def</span> <span class="nf">load_set_nodes_from_msgpack</span><span class="p">(</span><span class="n">storage_scc</span><span class="p">,</span> <span class="n">list_current_scc</span><span class="p">,</span> <span class="n">scc_2_offset</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get nodes inside each considered scc using an offset to fast random access (via peek())</span>
<span class="sd">    :param storage_scc: Storage of SCC (msgpack format (scf ?))</span>
<span class="sd">    :param list_current_scc: List of scc id&#39;s</span>
<span class="sd">    :param scc_2_offset: dictionary id_scc &lt;-&gt; offset (in the msgpack file)</span>
<span class="sd">    :return: A dictionary id_scc &lt;-&gt; nodes (inside the scc)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dict_id_2_set_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="n">list_current_scc</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">storage_scc</span> <span class="o">+</span> <span class="s2">&quot;scc.scf&quot;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ipt</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">list_current_scc</span><span class="p">:</span>
            <span class="n">ipt</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">scc_2_offset</span><span class="p">[</span><span class="n">id_scc</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">Unpacker</span><span class="p">(</span><span class="n">ipt</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">dict_id_2_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">dict_id_2_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dict_id_2_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">dict_id_2_set_nodes</span><span class="p">[</span><span class="n">id_scc</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dict_id_2_set_nodes</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1">#</span>

    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/&quot;</span> <span class="o">+</span> <span class="s2">&quot;Socio_Patterns/Workplace/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;Workplace&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/&quot;</span>
    <span class="c1"># __file__ = &quot;generated&quot;</span>
    <span class="c1"># __file__ =&quot;example&quot;</span>
    <span class="c1"># __file__ = &quot;High_School_2013&quot;</span>

    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/&quot;</span> <span class="o">+</span> <span class="s2">&quot;Socio_Patterns/High_School_2013/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;High_School_2013&quot;</span>

    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/Crawdad/Rollernet/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;rollernet&quot;</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Crawdad/Infocom/&quot;</span>
    <span class="c1"># __file__ = &quot;infocom&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Bitcoin/bitcoin_otc/&quot;</span>
    <span class="c1"># __file__ = &quot;bitcoin_otc&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Bitcoin/bitcoin_alpha/&quot;</span>
    <span class="c1"># __file__ = &quot;bitcoin_alpha&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/CollegeMsg/&quot;</span>
    <span class="c1"># __file__ = &quot;CollegeMsg&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/Enron/&quot;</span>
    <span class="c1"># __file__ = &quot;enron&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/parse_net/11September/&quot;</span>
    <span class="c1"># __file__ = &quot;Days&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/askubuntu/&quot;  # LIP6</span>
    <span class="c1"># __file__ = &quot;askubuntu&quot; # Open With Crawdad</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/DBLP/&quot;  # LIP6</span>
    <span class="c1"># __file__ = &quot;dblp&quot; # Open With Crawdad</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/example_paper/&quot;</span>
    <span class="c1"># __file__ =&quot;example_paper&quot;</span>
    <span class="c1">#</span>
    <span class="n">__directory__</span> <span class="o">=</span> <span class="s2">&quot;/home/leo/Dev/Data_Stream/&quot;</span>
    <span class="n">__filedate__</span> <span class="o">=</span> <span class="s2">&quot;sg_generated&quot;</span>



    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Straph/examples/&quot;</span>
    <span class="c1"># __file__ = &quot;example_path&quot;</span>
    <span class="c1">#</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/slashdot/&quot;</span>
    <span class="c1"># __file__ = &quot;slashdot-threads&quot;</span>

    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/ITS/&quot;</span>
    <span class="c1"># __file__ = &quot;Suricata&quot;</span>
    <span class="c1"># __directory__ = &quot;/home/leo/Dev/Data_Stream/path_examples/&quot;</span>
    <span class="c1"># __file__ = &quot;path_example&quot;</span>

    <span class="n">storage_path_scc</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_scc_storage/&quot;</span>
    <span class="n">storage_path_scc_dag</span> <span class="o">=</span> <span class="n">__directory__</span> <span class="o">+</span> <span class="n">__filedate__</span> <span class="o">+</span> <span class="s2">&quot;_scc_dag_storage/&quot;</span>

    <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">storage_path_scc_dag</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">dict_scc_dag</span> <span class="o">=</span> <span class="n">load_scc_dag_scf</span><span class="p">(</span><span class="n">storage_path_scc_dag</span> <span class="o">+</span> <span class="s1">&#39;scc_dag.scf&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of dag with at least 2 nodes :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_scc_dag</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dict scc dag :&quot;</span><span class="p">,</span> <span class="n">dict_scc_dag</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total number of nodes :&quot;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>

    <span class="c1">##########################</span>
    <span class="c1">#  COMPUTE SCC DAG LINKS #</span>
    <span class="c1">##########################</span>
    <span class="n">profile_shit</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                 <span class="s2">&quot;compute_links_msgpack(storage_path_scc,dict_scc_dag,storage_path_scc_dag)&quot;</span><span class="p">)</span>
    <span class="n">compute_dict_offset</span><span class="p">(</span><span class="n">storage_path_scc</span> <span class="o">+</span> <span class="s1">&#39;scc.scf&#39;</span><span class="p">,</span> <span class="n">storage_path_scc_dag</span> <span class="o">+</span> <span class="s2">&quot;dict_offset_scc.mpck&quot;</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># TODO : - Mettre le compute dict offset, une seule fois, garder les offsets une fois pour toute.</span>
    <span class="c1"># TODO : - Checker les foremost paths ~ pour workplace and high_school == tps minimal pour qu&#39;une information transite.</span>
    <span class="c1"># TODO : - Rajouter + Checker Fastest Path.</span>
    <span class="n">exit</span><span class="p">()</span>
    <span class="c1">########################</span>
    <span class="c1">#       PATHS          #</span>
    <span class="c1">########################</span>
    <span class="n">dict_scc_dag</span> <span class="o">=</span> <span class="n">load_scc_dag_scf</span><span class="p">(</span><span class="n">storage_path_scc_dag</span> <span class="o">+</span> <span class="s1">&#39;scc_dag_with_links.scf&#39;</span><span class="p">)</span>
    <span class="c1"># Get interesting WCC :</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">300</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">id_wcc : &quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n links :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">c_links</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n nodes :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">))</span>

    <span class="n">id_wcc</span> <span class="o">=</span> <span class="mi">7987</span>
    <span class="c1"># id_wcc = 1864</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">c_links</span><span class="p">)</span>
    <span class="n">dict_offset</span> <span class="o">=</span> <span class="n">msgpack</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">storage_path_scc_dag</span> <span class="o">+</span> <span class="s1">&#39;dict_offset_scc.mpck&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">),</span> <span class="n">use_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">id_scc</span> <span class="ow">in</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">c_nodes</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">load_scc_from_msgpack</span><span class="p">(</span><span class="n">id_wcc</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">,</span> <span class="n">storage_path_scc</span><span class="p">,</span> <span class="n">dict_offset</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; id scc :&quot;</span><span class="p">,</span> <span class="n">id_scc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n :&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="c1"># paths,duration =dict_scc_dag[id_wcc].foremost_path(source=1412,destination=1218,begin_time=1385982620,</span>
    <span class="c1">#                                    scc_storage=storage_path_scc,dict_offset_scc=dict_offset_scc)</span>
    <span class="c1"># print(&quot;Foremost Paths :&quot;,paths)</span>
    <span class="c1"># print(&quot;Duration :&quot;,duration)</span>

    <span class="n">paths</span><span class="p">,</span> <span class="n">latency</span> <span class="o">=</span> <span class="n">dict_scc_dag</span><span class="p">[</span><span class="n">id_wcc</span><span class="p">]</span><span class="o">.</span><span class="n">fastest_path</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="mi">205</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="mi">275</span><span class="p">,</span>
                                                       <span class="n">scc_storage</span><span class="o">=</span><span class="n">storage_path_scc</span><span class="p">,</span> <span class="n">dict_offset</span><span class="o">=</span><span class="n">dict_offset</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fastest Paths :&quot;</span><span class="p">,</span> <span class="n">paths</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nb Fastest Paths :&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Latency :&quot;</span><span class="p">,</span> <span class="n">latency</span><span class="p">)</span>

    <span class="c1"># load_dag_from_ids(1,0,storage_path_scc+&#39;scc.scf&#39;)</span>
    <span class="c1"># load_dag_from_ids(3,11,storage_path_scc+&#39;scc.scf&#39;)</span>
    <span class="c1"># list_scc_dag = compute_links_scf(storage_path_scc,dict_scc_dag,storage_path_scc_dag)</span>

    <span class="c1"># p = pathlib.Path(storage_path_scc_dag)</span>
    <span class="c1"># for filename in list(p.glob(&#39;*_nodes.mspk&#39;)):</span>
    <span class="c1">#     n_wcc = re.search(r&#39;\d+&#39;, os.path.basename(filename)).group()</span>
    <span class="c1">#     S = load_scc_dag(filename)</span>
    <span class="c1">#     S.compute_links(storage_path_scc+n_wcc+&quot;/&quot;,n_wcc,storage_path_scc_dag)</span>
    <span class="c1">#     # print(&quot;  nodes :&quot;,S.c_nodes)</span>
    <span class="c1">#     # print(&quot;  links :&quot;,S.c_links)</span>
    <span class="c1">#     if 10000 &gt; len(S.c_nodes) &gt; 100:</span>
    <span class="c1">#         print(&quot;node path :&quot;, filename)</span>
    <span class="c1">#         # S.plot()</span>
    <span class="c1">#         # plt.show()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019, Eol Ournan.
      Last updated on Oct 22, 2019.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>